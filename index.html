<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evolving Starfighter</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            /* Prevents selection and context menus on touch devices */
            touch-action: none; 
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none;
            z-index: 10;
        }
        #score-display {
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px #00d2ff;
        }
        #weapon-display {
            font-size: 16px;
            color: #aaa;
            margin-top: 5px;
        }
        #game-over {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            z-index: 20;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
        }
        button {
            padding: 10px 20px;
            font-size: 18px;
            background: #00d2ff;
            border: none;
            cursor: pointer;
            color: #000;
            font-weight: bold;
            border-radius: 5px;
            box-shadow: 0 0 15px #00d2ff;
            transition: all 0.2s ease;
        }
        button:hover {
            background: #fff;
            box-shadow: 0 0 25px #fff;
        }
    </style>
</head>
<body>

    <div id="ui">
        <div id="score-display">SCORE: 0</div>
        <div id="weapon-display">WEAPON: MK-1 BLASTER</div>
    </div>

    <div id="game-over">
        <h1 style="font-size: 50px; margin-bottom: 10px; text-shadow: 0 0 20px red;">CRITICAL FAILURE</h1>
        <p id="final-score">Final Score: 0</p>
        <br>
        <button onclick="resetGame()">REBOOT SYSTEM</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // --- Configuration ---
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let score = 0;
    let gameOver = false;
    let frame = 0;
    let weaponLevel = 1;

    // --- Input Global Variables for Touch/Mobile ---
    let touchPos = { x: 0, y: 0 };
    let touchActive = false; // Tracks if a touch is active for movement
    let isShooting = false; // Tracks if a touch is active for firing

    // Inputs: WASD, Arrow Keys, Space
    const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, w: false, a: false, s: false, d: false, " ": false };

    window.addEventListener('keydown', (e) => keys[e.key] = true);
    window.addEventListener('keyup', (e) => keys[e.key] = false);
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });

    // --- Touch Event Handlers for Mobile ---
    canvas.addEventListener('touchstart', handleTouchStart);
    canvas.addEventListener('touchmove', handleTouchMove);
    canvas.addEventListener('touchend', handleTouchEnd);
    canvas.addEventListener('touchcancel', handleTouchEnd);

    function handleTouchStart(e) {
        e.preventDefault();
        // Use the first touch for input tracking
        const touch = e.touches[0]; 
        touchPos = { x: touch.clientX, y: touch.clientY };

        // Movement is handled by touching the left half of the screen
        if (touch.clientX < canvas.width / 2) {
            touchActive = true;
            isShooting = false; 
        } 
        // Shooting is handled by tapping/holding the right half
        else {
            isShooting = true;
            touchActive = false;
        }
    }

    function handleTouchMove(e) {
        e.preventDefault();
        const touch = e.touches[0];
        // Only update position if we are in movement mode
        if (touchActive) {
            touchPos = { x: touch.clientX, y: touch.clientY };
        }
    }

    function handleTouchEnd(e) {
        e.preventDefault();
        // Stop all touch-related input when finger lifts
        touchActive = false;
        isShooting = false;
    }

    // --- Classes ---

    class Player {
        constructor() {
            this.x = canvas.width / 2;
            this.y = canvas.height - 100;
            this.width = 40;
            this.height = 60;
            this.speed = 6;
            this.lastShot = 0;
        }

        update() {
            // --- MOVEMENT LOGIC (Touch Priority) ---
            if (touchActive) {
                // Ship moves toward the current touch position (Follow/Drag style)
                const targetX = touchPos.x - this.width / 2;
                const targetY = touchPos.y - this.height / 2;

                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 1) { 
                    // Calculate normalized velocity and cap it at player speed
                    const velocityX = Math.min(Math.abs(dx), this.speed) * Math.sign(dx);
                    const velocityY = Math.min(Math.abs(dy), this.speed) * Math.sign(dy);

                    this.x += velocityX;
                    this.y += velocityY;
                }
            } else {
                // Keyboard movement fallback
                if ((keys.ArrowUp || keys.w) && this.y > 0) this.y -= this.speed;
                if ((keys.ArrowDown || keys.s) && this.y < canvas.height - this.height) this.y += this.speed;
                if ((keys.ArrowLeft || keys.a) && this.x > 0) this.x -= this.speed;
                if ((keys.ArrowRight || keys.d) && this.x < canvas.width - this.width) this.x += this.speed;
            }
            
            // Boundary checks
            this.x = Math.max(0, Math.min(this.x, canvas.width - this.width));
            this.y = Math.max(0, Math.min(this.y, canvas.height - this.height));


            // Weapon Evolution Logic
            if (score < 500) weaponLevel = 1;
            else if (score < 1500) weaponLevel = 2;
            else if (score < 3000) weaponLevel = 3;
            else weaponLevel = 4;

            updateUI();

            // Shooting
            const isFiring = keys[" "] || isShooting; // Combine spacebar and touch shooting
            if (isFiring && frame - this.lastShot > this.getFireRate()) {
                this.fire();
                this.lastShot = frame;
            }
        }

        getFireRate() {
            if (weaponLevel === 4) return 5; // Fastest firing rate
            return 15;
        }

        fire() {
            // Weapon Logic based on level
            if (weaponLevel === 1) {
                // Single Blaster
                bullets.push(new Bullet(this.x + this.width/2, this.y, 0, -10, 1));
            } else if (weaponLevel === 2) {
                // Twin Fire
                bullets.push(new Bullet(this.x, this.y + 10, 0, -10, 2));
                bullets.push(new Bullet(this.x + this.width, this.y + 10, 0, -10, 2));
            } else if (weaponLevel === 3) {
                // Tri-Spread
                bullets.push(new Bullet(this.x + this.width/2, this.y, 0, -10, 3));
                bullets.push(new Bullet(this.x, this.y + 10, -2, -9, 3));
                bullets.push(new Bullet(this.x + this.width, this.y + 10, 2, -9, 3));
            } else if (weaponLevel === 4) {
                // Plasma Stream
                bullets.push(new Bullet(this.x + this.width/2 - 10, this.y, 0, -15, 4));
                bullets.push(new Bullet(this.x + this.width/2 + 10, this.y, 0, -15, 4));
            }
        }

        draw() {
            ctx.save();
            ctx.translate(this.x + this.width/2, this.y + this.height/2);
            
            // Realistic Engine Glow
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#00d2ff';
            
            // Main Body (Metallic Gradient)
            let grad = ctx.createLinearGradient(-20, 0, 20, 0);
            grad.addColorStop(0, '#333');
            grad.addColorStop(0.5, '#888');
            grad.addColorStop(1, '#333');
            
            // Ship Hull (Procedural Geometry)
            ctx.beginPath();
            ctx.fillStyle = grad;
            ctx.moveTo(0, -30); // Nose
            ctx.lineTo(20, 20); // Right Wing tip
            ctx.lineTo(10, 30); // Right Engine
            ctx.lineTo(-10, 30); // Left Engine
            ctx.lineTo(-20, 20); // Left Wing tip
            ctx.closePath();
            ctx.fill();

            // Cockpit Canopy
            ctx.fillStyle = '#001133';
            ctx.beginPath();
            ctx.ellipse(0, -5, 5, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // Engine Flames (Animated)
            ctx.fillStyle = `rgba(0, 210, 255, ${Math.random() * 0.5 + 0.5})`;
            ctx.beginPath();
            ctx.moveTo(-8, 32);
            ctx.lineTo(0, 45 + Math.random() * 10);
            ctx.lineTo(8, 32);
            ctx.fill();

            ctx.restore();
        }
    }

    class Bullet {
        constructor(x, y, vx, vy, level) {
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.vy = vy;
            this.level = level;
            this.markedForDeletion = false;
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            if (this.y < 0) this.markedForDeletion = true;
        }

        draw() {
            ctx.save();
            ctx.beginPath();
            if (this.level === 1) {
                // Yellow single
                ctx.fillStyle = '#ffff00';
                ctx.shadowBlur = 5;
                ctx.shadowColor = 'yellow';
                ctx.arc(this.x, this.y, 3, 0, Math.PI*2);
            } else if (this.level === 2 || this.level === 3) {
                // Green laser
                ctx.fillStyle = '#00ff00';
                ctx.shadowBlur = 8;
                ctx.shadowColor = '#00ff00';
                ctx.rect(this.x - 2, this.y - 10, 4, 15);
            } else {
                // Blue plasma
                ctx.fillStyle = '#00d2ff';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00d2ff';
                ctx.rect(this.x - 3, this.y - 20, 6, 40);
            }
            ctx.fill();
            ctx.restore();
        }
    }

    class Enemy {
        constructor(type) {
            this.markedForDeletion = false;
            this.type = type; // 0 = Asteroid, 1 = Interceptor Ship
            this.x = Math.random() * (canvas.width - 50);
            this.y = -100;
            this.width = type === 0 ? 50 : 40;
            this.height = type === 0 ? 50 : 40;
            this.hp = type === 0 ? 2 : 3;
            
            // Movement logic
            this.vy = type === 0 ? Math.random() * 2 + 1 : Math.random() * 3 + 3;
            this.vx = type === 0 ? (Math.random() - 0.5) : 0;
            
            // Rotation for asteroids
            this.angle = 0;
            this.va = (Math.random() - 0.5) * 0.1;
        }

        update() {
            this.y += this.vy;
            this.x += this.vx;
            this.angle += this.va;

            // Interceptor specific tracking
            if (this.type === 1) {
                // Simple horizontal tracking towards the player
                if (player.x + player.width/2 > this.x + this.width/2) this.x += 0.5;
                else if (player.x + player.width/2 < this.x + this.width/2) this.x -= 0.5;
            }

            if (this.y > canvas.height) this.markedForDeletion = true;
        }

        draw() {
            ctx.save();
            ctx.translate(this.x + this.width/2, this.y + this.height/2);
            ctx.rotate(this.angle);

            if (this.type === 0) {
                // ASTEROID DESIGN
                ctx.fillStyle = '#555';
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.moveTo(-20, -20);
                ctx.lineTo(0, -25);
                ctx.lineTo(20, -15);
                ctx.lineTo(25, 0);
                ctx.lineTo(15, 20);
                ctx.lineTo(-10, 25);
                ctx.lineTo(-25, 10);
                ctx.closePath();
                ctx.fill();
                // Craters
                ctx.fillStyle = '#444';
                ctx.beginPath(); ctx.arc(-5, -5, 5, 0, Math.PI*2); ctx.fill();
            } else {
                // ENEMY SHIP DESIGN (Aggressor)
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'red';
                ctx.fillStyle = '#800';
                
                ctx.beginPath();
                ctx.moveTo(0, 20);
                ctx.lineTo(20, -20);
                ctx.lineTo(0, -10); // Notch
                ctx.lineTo(-20, -20);
                ctx.closePath();
                ctx.fill();
                
                // Engine Thruster
                ctx.fillStyle = 'orange';
                ctx.beginPath(); ctx.arc(0, -15, 3, 0, Math.PI*2); ctx.fill();
            }

            ctx.restore();
        }
    }

    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 10;
            this.vy = (Math.random() - 0.5) * 10;
            this.life = 1.0;
            this.color = color;
            this.markedForDeletion = false;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life -= 0.05;
            if (this.life <= 0) this.markedForDeletion = true;
        }
        draw() {
            ctx.save();
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 3, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        }
    }

    class Star {
        constructor() {
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.size = Math.random() * 2;
            this.speed = Math.random() * 3 + 0.5;
        }
        update() {
            this.y += this.speed;
            if (this.y > canvas.height) {
                this.y = 0;
                this.x = Math.random() * canvas.width;
            }
        }
        draw() {
            ctx.fillStyle = 'white';
            ctx.globalAlpha = Math.random() * 0.5 + 0.5;
            ctx.fillRect(this.x, this.y, this.size, this.size);
            ctx.globalAlpha = 1.0;
        }
    }

    // --- Global Variables ---
    let player;
    let bullets = [];
    let enemies = [];
    let particles = [];
    let stars = [];

    function updateUI() {
        document.getElementById('score-display').innerText = "SCORE: " + score;
        let wName = "MK-1 BLASTER";
        if(weaponLevel === 2) wName = "MK-2 TWIN-FIRE";
        if(weaponLevel === 3) wName = "MK-3 TRI-SPREAD";
        if(weaponLevel === 4) wName = "MK-4 PLASMA STREAM";
        document.getElementById('weapon-display').innerText = "WEAPON: " + wName;
    }

    function resetGame() {
        init();
    }

    function init() {
        player = new Player();
        bullets = [];
        enemies = [];
        particles = [];
        stars = [];
        score = 0;
        gameOver = false;
        weaponLevel = 1;
        document.getElementById('game-over').style.display = 'none';

        // Create stars for the background
        for(let i=0; i<100; i++) stars.push(new Star());
        
        loop();
    }

    function loop() {
        if (gameOver) return;
        requestAnimationFrame(loop);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        frame++;

        // 1. Draw and Update Background
        stars.forEach(star => { star.update(); star.draw(); });

        // 2. Player Logic
        player.update();
        player.draw();

        // 3. Enemy Spawning (Difficulty increases with score)
        if (frame % 60 === 0) {
            enemies.push(new Enemy(0)); // Asteroids
            if (score > 500 && Math.random() > 0.5) enemies.push(new Enemy(1)); // Ships start appearing
        }
        if (score > 2000 && frame % 40 === 0) enemies.push(new Enemy(1)); // More frequent ships

        // 4. Update and Filter Bullets
        bullets.forEach((bullet, index) => {
            bullet.update();
            bullet.draw();
        });
        bullets = bullets.filter(bullet => !bullet.markedForDeletion);

        // 5. Collision Detection & Enemy Handling
        enemies.forEach((enemy, index) => {
            enemy.update();
            enemy.draw();

            // Collision: Bullet vs Enemy
            bullets.forEach(bullet => {
                if (!bullet.markedForDeletion && 
                    bullet.x > enemy.x && bullet.x < enemy.x + enemy.width &&
                    bullet.y > enemy.y && bullet.y < enemy.y + enemy.height) {
                        
                    bullet.markedForDeletion = true;
                    enemy.hp--;
                    // Impact particles
                    for(let i=0; i<3; i++) particles.push(new Particle(bullet.x, bullet.y, 'orange'));

                    if (enemy.hp <= 0) {
                        enemy.markedForDeletion = true;
                        score += (enemy.type === 0 ? 100 : 250);
                        // Explosion particles
                        for(let i=0; i<15; i++) particles.push(new Particle(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.type === 0 ? 'grey' : 'red'));
                    }
                }
            });

            // Collision: Enemy vs Player
            // Simple box collision (reduced collision area for fairness)
            if (player.x < enemy.x + enemy.width - 10 &&
                player.x + player.width > enemy.x + 10 &&
                player.y < enemy.y + enemy.height - 10 &&
                player.y + player.height > enemy.y + 10) {
                    gameOver = true;
                    document.getElementById('final-score').innerText = "Final Score: " + score;
                    document.getElementById('game-over').style.display = 'block';
            }
        });

        // 6. Filter Enemies
        enemies = enemies.filter(enemy => !enemy.markedForDeletion);

        // 7. Particle Effects
        particles.forEach(p => { p.update(); p.draw(); });
        particles = particles.filter(p => !p.markedForDeletion);
    }

    // Start the Game
    init();

</script>
</body>
</html>
